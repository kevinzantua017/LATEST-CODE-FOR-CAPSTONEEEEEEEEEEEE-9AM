# On the Pi
cd ~/Ped_Scanner  # (your project folder)
python3 -m pip install --user --upgrade pip
python3 -m pip install --user opencv-python numpy paho-mqtt pillow luma.core luma.led_matrix

cat > pi_publisher.py <<'PY'
import os, time, json, threading
from urllib.parse import urlparse, unquote
import cv2, numpy as np
import paho.mqtt.client as mqtt

# ---- ENV ----
SITE_ID = os.getenv("SC_SITE_ID", "adsmn-01")
MQTT_URL= os.getenv("SC_MQTT_URL")  # same URL as the VM used
CAM_PED = os.getenv("SC_CAM_PED", "0")
CAM_VEH = os.getenv("SC_CAM_VEH", "1")
CAM_TL  = os.getenv("SC_CAM_TL",  "2")
FRAME_W = int(os.getenv("SC_FRAME_W", "640"))
FRAME_H = int(os.getenv("SC_FRAME_H", "360"))
FPS     = int(os.getenv("SC_FPS", "10"))

if not MQTT_URL:
    raise SystemExit("SC_MQTT_URL not set on Pi")

# LED (optional)
def init_led():
    try:
        from luma.core.interface.serial import spi, noop
        from luma.led_matrix.device import max7219
        from luma.core.render import canvas
        from PIL import ImageFont
        serial = spi(port=0, device=0, gpio=noop())
        device = max7219(serial, cascaded=int(os.getenv("SC_LED_CASCADE","4")),
                         block_orientation=int(os.getenv("SC_LED_ORIENTATION","-90")), rotate=0)
        font = ImageFont.load_default()
        def show(text):
            with canvas(device) as draw:
                draw.text((1, -2), text, fill="white", font=font)
        print("[LED] MAX7219 OK")
        return show
    except Exception as e:
        print("[LED] fallback console:", repr(e))
        return lambda text: print("[LED]", text)

show_led = init_led()

# ---- MQTT ----
def parse_mqtt_url(url):
    u = urlparse(url)
    if u.scheme not in ("mqtt","mqtts"):
        raise ValueError("SC_MQTT_URL must be mqtt:// or mqtts://")
    return (u.hostname, u.port or (8883 if u.scheme=="mqtts" else 1883),
            unquote(u.username) if u.username else None,
            unquote(u.password) if u.password else None,
            u.scheme=="mqtts")

HOST, PORT, USER, PASSWD, USE_TLS = parse_mqtt_url(MQTT_URL)

TOP_PED = f"crosswalk/{SITE_ID}/frames/ped"
TOP_VEH = f"crosswalk/{SITE_ID}/frames/veh"
TOP_TL  = f"crosswalk/{SITE_ID}/frames/tl"
TOP_DEC = f"crosswalk/{SITE_ID}/decision"

client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, client_id=f"pi-pub-{SITE_ID}", clean_session=True)
if USER:
    client.username_pw_set(USER, PASSWD)
if USE_TLS:
    client.tls_set()

def on_connect(client, userdata, flags, reason, props=None):
    print("[MQTT] Connected:", reason)
    client.subscribe(TOP_DEC, qos=0)

def on_message(client, userdata, msg):
    try:
        j = json.loads(msg.payload.decode("utf-8", errors="ignore"))
        action = j.get("action","OFF")
        show_led(action)
        print("[DECISION]", j)
    except Exception as e:
        print("[MQTT] decision parse error:", e)

client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT, keepalive=30)
client.loop_start()

# ---- Cameras ----
def normalize_cam(v):
    s = str(v).strip()
    if s.isdigit(): return int(s)
    return s

cams = {
    "ped": normalize_cam(CAM_PED),
    "veh": normalize_cam(CAM_VEH),
    "tl":  normalize_cam(CAM_TL),
}
caps = {}
for k, idx in cams.items():
    cap = cv2.VideoCapture(idx)
    if not cap.isOpened():
        print(f"[WARN] camera {k} ({idx}) not opened")
        caps[k] = None
        continue
    cap.set(cv2.CAP_PROP_FRAME_WIDTH,  FRAME_W)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_H)
    cap.set(cv2.CAP_PROP_FPS, FPS)
    caps[k] = cap
    print(f"[OPEN] {k} -> {idx}")

topic_map = {"ped": TOP_PED, "veh": TOP_VEH, "tl": TOP_TL}
period = 1.0/max(1,FPS)

try:
    while True:
        t0 = time.time()
        for k, cap in caps.items():
            if cap is None: continue
            ok, frame = cap.read()
            if not ok or frame is None: continue
            if frame.shape[1]!=FRAME_W or frame.shape[0]!=FRAME_H:
                frame = cv2.resize(frame, (FRAME_W, FRAME_H), interpolation=cv2.INTER_AREA)
            # encode JPEG and publish raw bytes (not base64)
            ok, buf = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), 70])
            if ok:
                client.publish(topic_map[k], buf.tobytes(), qos=0, retain=False)
        dt = time.time()-t0
        if dt < period:
            time.sleep(period-dt)
except KeyboardInterrupt:
    pass
finally:
    for cap in caps.values():
        try:
            if cap: cap.release()
        except: pass
    client.loop_stop()
    client.disconnect()
PY
