cd ~/Ped_Scanner
cat > pi_publisher.py <<'PY'
import os, time, json, threading, ssl
from urllib.parse import urlparse, unquote
import cv2, numpy as np
import paho.mqtt.client as mqtt
from dotenv import load_dotenv

# ---------- ENV ----------
load_dotenv(".env.pi")
SITE_ID = os.getenv("SC_SITE_ID", "adsmn-01")
MQTT_URL= os.getenv("SC_MQTT_URL")
CAM_PED = os.getenv("SC_CAM_PED", "0")
CAM_VEH = os.getenv("SC_CAM_VEH", "1")
CAM_TL  = os.getenv("SC_CAM_TL",  "2")
FRAME_W = int(os.getenv("SC_FRAME_W", "640"))
FRAME_H = int(os.getenv("SC_FRAME_H", "360"))
FPS     = int(os.getenv("SC_FPS", "8"))

if not MQTT_URL:
    raise SystemExit("SC_MQTT_URL is not set. Put it in .env.pi")

# ---------- LED (optional) ----------
def _init_led():
    try:
        from luma.core.interface.serial import spi, noop
        from luma.led_matrix.device import max7219
        from luma.core.render import canvas
        from PIL import ImageFont
        serial = spi(port=0, device=0, gpio=noop())
        device = max7219(serial, cascaded=int(os.getenv("SC_LED_CASCADE","4")),
                         block_orientation=int(os.getenv("SC_LED_ORIENTATION","-90")), rotate=0)
        font = ImageFont.load_default()
        def show_led(msg: str):
            with canvas(device) as draw:
                draw.text((1, -2), msg[:8], fill="white", font=font) # 8-char fit
        print("[LED] MAX7219 ready")
        return show_led
    except Exception as e:
        print("[LED] Not available:", repr(e))
        return lambda msg: None

show_led = _init_led()

# ---------- MQTT ----------
u = urlparse(MQTT_URL)
scheme = u.scheme
host   = u.hostname
port   = u.port or (8883 if scheme=="mqtts" else 1883)
user   = unquote(u.username) if u.username else None
pw     = unquote(u.password) if u.password else None

topic_frames_base   = f"crosswalk/{SITE_ID}/frames"
topic_decision      = f"crosswalk/{SITE_ID}/decision"
topic_hello         = f"crosswalk/{SITE_ID}/pi_hello"

client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, client_id=f"pi-{SITE_ID}-{int(time.time())}")

if user:
    client.username_pw_set(user, pw)

if scheme == "mqtts":
    # Use system CA store (HiveMQ Cloud requires TLS)
    client.tls_set(cert_reqs=ssl.CERT_REQUIRED)
    client.tls_insecure_set(False)

def on_connect(client, userdata, flags, rc, properties=None):
    print(f"[MQTT] Connected rc={rc}")
    client.subscribe(topic_decision, qos=0)
    client.publish(topic_hello, json.dumps({"site": SITE_ID, "ts": time.time(), "type":"pi"}),
                   qos=0, retain=False)

def on_message(client, userdata, msg):
    if msg.topic == topic_decision:
        try:
            data = json.loads(msg.payload.decode("utf-8"))
        except Exception:
            print("[MQTT] decision payload not JSON")
            return
        action = str(data.get("action","OFF")).upper()
        scenario = data.get("scenario","")
        print(f"[DECISION] {action} {f'({scenario})' if scenario else ''}")
        # Reflect on LED
        if action == "STOP":
            show_led("STOP")
        elif action == "GO":
            show_led("GO")
        else:
            show_led("OFF")

client.on_connect = on_connect
client.on_message = on_message
client.connect(host, port, keepalive=30)

# Start network loop in background
client.loop_start()

# ---------- Cameras ----------
def _open_cam(idx):
    # idx can be "0", "1", "/dev/video2", or rtsp/http url
    try:
        i = int(idx)
    except ValueError:
        i = idx
    cap = cv2.VideoCapture(i)
    if not cap.isOpened():
        # try V4L2 fallback
        cap = cv2.VideoCapture(i, cv2.CAP_V4L2)
    if not cap.isOpened():
        print(f"[CAM] Could not open {idx}")
        return None
    # set size (best-effort)
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_W)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_H)
    cap.set(cv2.CAP_PROP_FPS, FPS)
    return cap

cap_ped = _open_cam(CAM_PED)
cap_veh = _open_cam(CAM_VEH)
cap_tl  = _open_cam(CAM_TL)

def _pub_cam_loop(name, cap):
    if cap is None:
        return
    topic_base = f"{topic_frames_base}/{name}"
    period = 1.0 / max(1, FPS)
    while True:
        t0 = time.time()
        ok, frame = cap.read()
        if not ok or frame is None:
            time.sleep(0.05)
            continue
        if frame.shape[1] != FRAME_W or frame.shape[0] != FRAME_H:
            frame = cv2.resize(frame, (FRAME_W, FRAME_H), interpolation=cv2.INTER_AREA)
        # JPEG encode
        ok, buf = cv2.imencode(".jpg", frame, [int(cv2.IMWRITE_JPEG_QUALITY), 70])
        if not ok:
            continue
        ts = int(t0 * 1000)
        # payload small: just binary JPEG on a per-cam topic; VM matches by topic
        client.publish(topic_base, buf.tobytes(), qos=0, retain=False)

        # pace
        dt = time.time() - t0
        if dt < period:
            time.sleep(period - dt)

threads = []
for name, cap in (("ped", cap_ped), ("veh", cap_veh), ("tl", cap_tl)):
    th = threading.Thread(target=_pub_cam_loop, args=(name, cap), daemon=True)
    th.start()
    threads.append(th)

print("[PI] publishing framesâ€¦ (Ctrl+C to stop)")
try:
    while True:
        time.sleep(1.0)
except KeyboardInterrupt:
    pass
finally:
    client.loop_stop()
    client.disconnect()
    for cap in (cap_ped, cap_veh, cap_tl):
        try:
            if cap: cap.release()
        except: pass
PY
